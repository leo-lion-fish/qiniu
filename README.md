七牛云校招项目

### **1. 程序如何启动**

#### 1.1 **安装依赖**

执行以下命令安装项目依赖：

```bash
pip install -r requirements.txt
```

#### 1.2 **数据库配置**

配置数据库连接，在`.env`文件或环境变量中设置以下内容：

```bash
export DATABASE_URL="postgresql+psycopg2://qiniu:310270mjq@127.0.0.1:5432/ai_chat"
export REDIS_URL="redis://127.0.0.1:6379/0"
export QINIU_OPENAI_BASE="https://openai.qiniu.com/v1"
```

#### 1.3 **启动后端服务**

1. 进入项目根目录，执行以下命令启动后端服务：

```bash
./start.sh
```

2. `start.sh` 脚本将：

   * 设置环境变量。
   * 启动 **FastAPI** 服务，监听端口 `8000`。

#### 1.4 **启动前端服务**

1. 进入前端项目目录，执行以下命令安装前端依赖：

```bash
npm install
```

2. 执行以下命令启动前端服务：

```bash
npm run dev
```

3. 前端服务默认监听端口 `3000`。

---

### **总结**

* **后端**：使用 `./start.sh` 启动，监听端口 `8000`。
* **前端**：使用 `npm run dev` 启动，监听端口 `3000`。



---

### **2. 项目架构设计**

#### 2.1 **数据库表结构与Redis**

##### **2.1.1 数据库选择**

项目使用 **PostgreSQL** 作为数据库，原因如下：

* **关系型数据库**：PostgreSQL 是一个强大的关系型数据库，提供ACID事务保证，非常适合存储结构化数据，如会话信息、角色数据以及聊天历史记录。
* **扩展性**：PostgreSQL 支持大规模的数据集，适合扩展和高并发请求，同时也支持 JSONB 数据类型，提供了灵活的存储方式。
* **可靠性和一致性**：在处理多用户和多会话的数据时，PostgreSQL 可以保证数据的完整性和一致性。

##### **2.1.2 数据库表设计**

1. **`character_info` 表**：存储角色的详细信息，如角色名称、背景、性格、技能等。

   * **字段**：`id`、`name`、`background`、`skills`、`current_playstyle`、`personality`。
   * **索引**：`id` 是主键索引，`name` 则用作快速查询。

2. **`chat_sessions` 表**：存储会话信息，包括 `session_id`（会话ID）、`character_id`（绑定的角色ID）、`title`（会话标题）、`created_at`（创建时间）、`last_active_at`（最后活跃时间）。

   * **外键**：`character_id` 关联到 `character_info` 表，用于标识当前会话绑定的角色。

3. **`chat_history` 表**：存储会话中的消息记录，包括 `session_id`、`message`、`role`（角色：`user`、`assistant`、`system`）、`created_at`（消息创建时间）。

   * **索引**：`session_id` 和 `created_at` 上建立复合索引，便于按时间顺序查询历史消息。

##### **2.1.3 Redis 使用**

Redis 被用于存储会话历史和会话锁，原因如下：

* **高性能缓存**：Redis 提供快速的数据读取和写入，适用于缓存会话历史数据，减少对数据库的频繁访问，提高响应速度。
* **会话锁**：使用 Redis 实现会话锁机制，确保同一个会话不会被多个请求同时修改，避免并发问题。

---

#### 2.2 **后端框架**

##### **2.2.1 后端技术栈**

项目选择 **FastAPI** 作为后端框架，原因如下：

* **高性能**：FastAPI 基于 ASGI 协议，支持异步处理，具有极高的性能，适合构建高并发的 Web 应用。
* **自动生成文档**：FastAPI 会自动生成 API 文档，便于前端开发人员快速理解和使用后端接口。
* **简洁易用**：FastAPI 的设计理念简洁，基于 Python 3.6+ 的类型提示，提供了丰富的类型验证，避免了大量的手动检查和错误处理。
* **异步支持**：FastAPI 支持异步请求处理，使得 I/O 密集型任务（如数据库操作、API调用等）能够更高效地处理。

##### **2.2.2 后端架构设计**

* **路由**：后端的 API 路由遵循 RESTful 风格，每个资源都有独立的接口。比如会话相关的接口为 `/sessions`，角色相关的接口为 `/characters`。
* **数据库交互**：使用 SQLAlchemy 作为 ORM 工具与 PostgreSQL 进行交互。所有数据的增删改查通过 `crud.py` 模块实现，确保了后端与数据库的良好分离。
* **缓存处理**：使用 Redis 存储会话历史，通过 `redis_cache.py` 模块封装 Redis 操作，确保缓存的高效使用。

---

#### 2.3 **前端框架**

##### **2.3.1 前端技术栈**

项目选择 **React** 作为前端框架，原因如下：

* **组件化**：React 的组件化架构使得开发更具可维护性，UI 元素封装成小型的组件，方便重用和扩展。
* **虚拟DOM**：React 使用虚拟 DOM 来提高渲染性能，减少不必要的 DOM 操作，提升前端的响应速度。
* **社区支持与生态**：React 拥有庞大的开发者社区和生态系统，支持众多第三方库，方便集成各种功能。
* **前后端分离**：React 支持通过 API 与后端服务进行交互，非常适合开发单页应用（SPA），使得前后端可以独立开发和部署。

##### **2.3.2 前端架构设计**

* **组件结构**：前端应用通过 React 组件构建，包含会话管理组件、角色选择组件、消息显示组件等。
* **状态管理**：使用 React 的 `useState` 和 `useEffect` 来管理应用状态，例如当前会话、消息历史、角色信息等。
* **与后端交互**：前端通过 `fetch` 请求后端 API，获取数据并与用户进行交互。对于流式聊天，前端使用 `EventSource` 接收逐步返回的数据。

---

#### 2.4 **涉及的 API 调用**

##### **2.4.1 后端 API 调用**

1. **创建会话**：通过 `POST /sessions` 接口创建新会话，前端传递会话标题等信息。
2. **获取会话列表**：通过 `GET /sessions` 获取所有会话的信息，包括会话标题、角色信息、创建时间等。
3. **绑定角色**：通过 `POST /sessions/{sid}/bind-character` 绑定角色到指定会话，前端传递角色的 ID 或名称。
4. **聊天功能**：

   * **非流式聊天**：通过 `POST /chat` 接口发送消息并获取回复。
   * **流式聊天**：通过 `POST /chat/stream` 接口逐步获取模型回复，适用于实时对话场景。
5. **角色管理**：

   * **获取角色列表**：通过 `GET /characters` 获取所有角色的详细信息。
   * **创建角色**：通过 `POST /characters` 创建新角色，指定角色的名称、背景、技能等信息。

##### **2.4.2 七牛 OpenAI API 调用**

* **聊天模型调用**：使用七牛云提供的 API（`/v1/chat/completions`）与 OpenAI 兼容的大语言模型进行交互，处理用户消息并返回生成的回复。

  * 在流式聊天时，七牛API逐步返回模型的回复，前端实时显示消息。
  * **为什么使用浏览器自带的 ASR 而非七牛 API**：浏览器自带的 Web Speech API 提供了即时的语音识别（ASR）功能，无需额外的外部 API 调用，能够实现更加便捷的用户体验。同时，避免了额外的延迟和网络请求，提升了实时性。

---

### **总结**

1. **数据库**：PostgreSQL 用于存储结构化数据，Redis 用于缓存会话历史和实现会话锁。
2. **后端**：FastAPI 提供高性能的异步请求处理，支持自动文档生成，简化了开发和维护。
3. **前端**：React 提供高效的组件化开发，使用虚拟 DOM 提升性能，并与后端进行交互。
4. **API 调用**：前后端通过 RESTful API 进行交互，七牛 OpenAI API 提供聊天模型支持，浏览器自带的 ASR API 提供语音识别功能。

---

---

### **3. 一些细节上的设计**

#### 3.1 **前端界面优化**

1. **现代化与响应式设计**：

   * 前端使用 **React** 框架进行开发，结合 **CSS** 和 **JavaScript** 组件化开发，确保界面简洁且具有良好的用户体验。
   * 前端界面采用 **响应式设计**，适配不同屏幕尺寸，确保在手机、平板和桌面设备上都能流畅运行。

2. **会话管理**：

   * **会话历史按最近活跃时间排序**，确保用户在应用中始终能够优先看到最近使用的会话。
   * 支持 **修改会话名称**：用户可以在会话列表中点击并编辑标题，以便自定义标识会话内容。
   * **新建会话**：用户可以通过点击按钮快速创建新会话，每个会话都会出现在会话列表中，并分配唯一的 `session_id`。
   * **删除会话**：用户可以删除会话，删除时会同时删除：

     * Redis 中该会话的缓存。
     * 数据库中的会话记录（包括历史消息和角色绑定信息）。
   * 删除操作会进行 **双重确认**，防止误操作。

3. **角色选择与绑定**：

   * 在创建或管理会话时，用户可以选择角色进行绑定。所有角色信息从后端 `GET /characters` 接口加载，前端通过下拉框显示。
   * **角色切换**：在一个已创建的会话中，用户可以随时切换角色，系统会根据新的角色更新对话风格和内容。

#### 3.2 **角色选择与绑定**

* 用户可以从已有的角色中选择一个进行绑定，而不是创建新的角色。这一设计简化了前端流程，避免了不必要的角色数据输入和管理。
* **角色绑定与会话管理**：

  * 每个会话可以绑定 **一个角色**，角色决定了系统对话的风格。
  * 通过角色的 `system_prompt`，系统能够根据角色的背景、性格等信息生成符合角色特点的回复。
  * **角色切换**：在一个会话中，用户可以随时切换角色，系统会根据新的角色更新对话风格和内容。

#### 3.3 **语音合成与语音识别**

1. **语音合成（TTS）**：

   * 用户可以选择 **不同的音色** 来进行语音合成（TTS）。系统提供多个音色选项，如男性、女性、不同语调等。
   * 用户选择的音色会影响消息发送后自动播放的语音内容，提供了更个性化的语音体验。
   * **自动朗读**：用户可以启用 **自动朗读** 功能，系统在接收到回复后，会自动朗读模型生成的回复文本，增强交互体验。

2. **语音识别（ASR）**：

   * **浏览器自带的 ASR**：系统使用浏览器自带的 Web Speech API 来进行语音识别。此方案避免了外部依赖，减少了网络延迟，提高了识别速度和响应性。
   * 用户点击 **语音输入按钮** 后，浏览器会启动语音识别，识别后的文本会自动显示在输入框中，用户可进一步修改或直接发送。
   * 语音识别会将用户的口语转化为文字，减少输入的繁琐，特别适合需要快速输入或解放双手的场景。

#### 3.4 **模型选择与配置**

1. **模型选择**：

   * 前端提供了 **下拉框** 和 **手写输入** 两种选择方式，用户可以从预设的模型中选择，也可以手动输入自定义模型名称。
   * 用户选择的模型会影响后端调用的模型类型，不同的模型可能具有不同的对话风格和能力。
   * **兜底模型**：如果用户未选择模型，系统会默认使用 **兜底模型**。兜底模型通常是系统预设的最佳模型，作为所有请求的默认处理模型。

2. **精选模型**：

   * 在后端会维护一组精选模型，如 `deepseek-v3`、`claude-3.7-sonnet`、`gemini-2.5-flash-lite` 等。前端会根据这些精选模型提供选择，用户可以从中挑选使用。

#### 3.5 **并发设计与控制**

1. **Redis 分布式锁**：

   * 为了避免并发修改同一会话的数据，系统使用 **Redis 分布式锁** 来确保同一时刻只有一个客户端能够操作当前会话的数据。
   * 在多个浏览器同时访问同一会话时，如果一个会话正在被处理，其他浏览器将等待。直到锁被释放，才会继续操作。
   * Redis 锁的 **超时机制** 确保在长时间未响应的情况下，锁能被释放，避免死锁问题。

2. **请求顺序**：

   * 系统按照请求 **发送的顺序** 来排列显示效果。即使用户在多个浏览器上同时发送消息，系统也会按顺序返回消息，确保多设备交互的一致性。
   * **请求排队**：后端通过锁机制和消息队列的方式确保每个请求按照顺序处理，避免并发请求产生的顺序混乱。

3. **前端请求队列**：

   * 前端在发送消息时会为每条消息分配一个 **唯一的标识**，并通过消息队列来按顺序显示聊天内容。这保证了无论用户使用哪个设备，消息都能按发送顺序正确显示。

#### 3.6 **语音识别与文字发送**

1. **语音输入**：

   * 前端使用浏览器的 **Web Speech API** 进行语音识别。点击语音按钮后，浏览器开始监听用户的语音，并将语音转化为文本。
   * 识别后的文本显示在输入框中，用户可以选择继续编辑或直接发送。

2. **文字输入**：

   * 除了语音识别，用户还可以直接输入文本消息。系统会将输入的文字消息发送到后端，等待模型的回复。
   * **支持文字和语音混合输入**，即用户可以在同一个会话中既发送文字消息，也可以通过语音输入消息，增强了交互的灵活性。

#### 3.7 **界面与用户交互**

1. **用户友好的界面**：

   * 使用简洁的按钮、输入框和下拉框等组件来构建交互界面，使用户能够直观地进行操作。
   * 会话列表、角色选择、消息输入框等组件清晰可见，用户可以快速创建会话、绑定角色、发送消息。

2. **实时更新与交互**：

   * 使用 **Server-Sent Events (SSE)** 或 **WebSocket** 来实现消息的实时更新，确保用户在发送消息后能立即看到响应内容。
   * 前端会根据不同状态（如正在发送消息、等待回复、语音输入等）进行界面更新，提高用户交互的流畅性。

---

### **总结**

1. **前端优化与用户体验**：

   * 前端界面经过优化，简化了操作流程，提高了交互性，支持会话管理、角色选择、语音合成与识别等功能。

2. **语音与模型配置**：

   * 提供了语音合成音色选择、自动朗读选项，并支持多模型选择和手写模型配置，增强了系统的个性化和可定制性。

3. **并发控制与锁机制**：

   * 通过 Redis 分布式锁实现会话的并发控制，确保多个浏览器在同一会话中的请求顺序与一致性。

4. **语音识别与文字输入**：

   * 支持语音识别输入，结合文字输入功能，使得用户可以灵活地选择输入方式，提高了系统的易用性。

5. **实时更新与顺序控制**：

   * 系统通过消息队列和 Redis 锁机制确保消息的实时性和顺序性，避免并发请求时的显示混乱。



---

### **3. 系统框架图**
```mermaid
graph TD
    subgraph "User Interface (React/Vite Frontend)"
        A[用户浏览器] --> B(App.jsx)
        B -- "管理状态 (input, messages, error)" --> B
        B -- "管理并发重试 (isSessionLocked, retryAttempt)" --> B
        B -- "ref引用 (inputRef, audioRef)" --> B
        B -- "用户输入" --> B
    end

    subgraph "Backend API (FastAPI)"
        C[main.py: FastAPI 应用] --> D(app/redis_cache.py)
        C --> E(app/crud.py)
        C --> F(app/characters.py)
        C --> G(app/qiniu_llm.py)
        C -- "依赖注入 (db, rds)" --> D
        C -- "依赖注入 (db)" --> E
        C -- "依赖注入 (db)" --> F
    end

    subgraph "Data Storage & External Services"
        H[Redis: 缓存 & 分布式锁]
        I[PostgreSQL: 数据库]
        J[七牛云OpenAI兼容API LLM]  
        K[七牛云TTS API服务]        
    end

    B -- "发送消息 (POST /chat/stream)" --> C

    %% 并发控制与重试流程
    C -- "1. 尝试获取会话锁 (chat:lock:<session_id>)" --> H
    H -- "1.1 锁已存在" --> C_Locked{会话已锁定?}
    C_Locked -- "是 (HTTP 409 Conflict)" --> B
    B -- "2. 收到 409: 显示 '会话忙...', 指数退避自动重试" --> C
    H -- "1.2 锁获取成功" --> C

    %% 正常消息处理流程
    C -- "3. 获取历史消息 (chat:hist:<session_id>)" --> H
    H -- "3.1 Redis缓存未命中" --> E
    E -- "3.2 从数据库加载历史" --> I
    C -- "4. 构建System Prompt" --> F
    C -- "5. 调用 chat_completion_stream()" --> G
    G -- "6. 发起 LLM 请求 (HTTP)" --> J
    J -- "7. 流式 SSE 响应" --> G
    G -- "8. 流式 SSE (分块内容)" --> B
    B -- "9. 接收流并更新 UI (messages)" --> A

    %% 后处理与清理
    C -- "10. 保存消息对 (user/assistant)" --> H
    C -- "11. 写入数据库历史" --> E
    E -- "11.1 更新数据库" --> I
    C -- "12. 释放会话锁" --> H

    %% TTS (语音合成) 流程
    B -- "(消息处理完成后) speakIfNeeded()" --> K
    K -- "TTS 音频数据" --> B
    B -- "播放音频 (audioRef)" --> A

    %% 其他数据流
    B -- "获取会话列表/角色信息" --> C
    C -- "返回会话列表/角色信息" --> B
    C -- "更新会话最后活跃时间" --> E
    B -- "ASR语音转文字" --> C